出所：[初心者が知らないプログラミングの常識、なぜ「状態は悪」なのか](https://xtech.nikkei.com/atcl/nxt/column/18/00682/032300076/)

執筆時期：2022(R4).03.25

取得年月日：2023(R5).10.24

# 初心者が知らないプログラミングの常識、なぜ「状態は悪」なのか

　これまでこのコラムでは、プログラミング言語やソフトウエア開発といったプログラミング周辺の話題を取り上げてきた。一方、プログラミングそのものについてはあまり解説してこなかった。というのは、具体的なプログラミングに関心がある読者は必ずしも多くないと考えられるからだ。

　もっとも、せっかくタイトルに「プログラミング」とついているコラム連載である。たまにはそうした話題を正面から取り上げてみたいと思う。

　さて、「プログラムには状態がある」と聞いてピンとくる人はどれくらいいるだろうか。おそらく、プログラムを書いたことのない人は、何のことかわからないはずだ。逆に、きちんとプログラミングに取り組んでいるなら、「ああ、あの話題か」とすぐにわかるのではないだろうか。

　日常的にプログラムを書いているのにピンとこないなら、自身のプログラミングのレベルを疑ったほうがいいかもしれない。「プログラムには状態があり、状態はなるべく排除したほうがいい」というのは、プログラミングの解説書でたびたび取り上げられるテーマだ。優秀なプログラマーがこうした考え方を披露することも多い。

　プログラムの状態を担うのが「変数」である。端的にいえば、変数の値が変わることでプログラムの状態が変わる。「状態」という言葉がわかりにくければ、「モード」と言い換えてもいい。変数の値が変わることで、プログラムが別のモードになってしまうのだ。

　プログラミング初心者だと、「変数の値を書き換えるのは普通のことではないか。なぜそんなことをいちいち意識しなければならないのか」と考えるかもしれない。そこで、変数の値が変わることでプログラムの状態が変わり、不都合が起こる例を具体的に見てみよう。

#### 呼び出すごとに値が変わる関数

　学校の数学の授業では「関数」という概念を習う。「f（x）＝2x＋1」といった式に見覚えがある人は多いだろう。xの値が2のとき、この関数の値、すなわちf（2）は5だ。きまぐれで4になったり6になったりすることはない。必ず5である。xの値が決まれば、関数の値は一意に決まる。

　一方、プログラミングにも関数という概念がある。様々な処理をひとまとめにして名前をつけ、再利用しやすくするものだ。プログラミングの関数は引数（「ひきすう」と読む）として値をとり、それを適用した結果の値を返す。そうした意味で、数学の関数によく似ている。

　ただし、こうした関数は同じ引数に対して常に同じ値を返すとは限らない。場合によっては返す値が変わる可能性がある。その「場合」を左右するものこそがプログラムの状態だ。

　次のようなC言語のプログラムを考えてみよう。これを実行すると何が表示されるかわかるだろうか。

```
#include <stdio.h>

int state = 1;

int f(int x) {
  int result = 2 * x + state;
  state++;
  return result;
}

int main(void) {
  printf("f（2）の値は%dですn", f(2));
  printf("f（2）の値は%dですn", f(2));
  return 0;
}
```

　なんと「f（2）の値は5です」「f（2）の値は6です」が2行にわたって表示される。同じ2という引数を関数に渡しても、返ってくる値が変わってしまうのだ。

　プログラムの内容を見てみよう。まず「int state = 1;」でstateという整数型の変数を宣言し、1という値を代入している。この位置で変数を宣言すると、プログラム全体で有効な変数になる。こうした変数を「グローバル変数」や「大域変数」と呼ぶ。

　fという関数の定義では、引数の値を2倍してstateの値を加え、resultという変数に入れている。「＋＋」はインクリメント演算子で、変数に1を加えるものだ。ここではstateの値を1だけ増やしている。そして関数の値としてresultを返している。

　f関数を呼び出すと、resultを計算して返すとともにstateに1が足される。次にf関数を呼び出したときは、1が足されたstateを計算に使うため、返す値が変わる。では、同じprintf文をもう1行追加すると、値として何が表示されるだろうか。もうおわかりだろう。「7」だ。

　このようにプログラムの状態が変化し、その状態が処理の結果に影響を与えるプログラムでは、ミスが起こりやすくなる。プログラムの動作をプログラマーが頭の中でなぞり、そのときの変数の値、すなわち状態がどうなっているかを常に意識しながらロジックを書かなければならないからだ。

　先に挙げたC言語のプログラムで、状態を決めているのがstateというグローバル変数だった。グローバル変数が特にやっかいなのは、プログラムのサイズが大きくなったときだ。どこでグローバル変数が使われているのかを把握するのが困難になり、ある場所でグローバル変数の値を変更すると、意図しない場所に悪影響が出るといったことが起こる。

　こうした問題があることから、現在ではグローバル変数はほとんど使われなくなっている。代わりに多用されているのがローカル変数（局所変数）だ。有効範囲がプログラム全体ではなく、関数内など限られた範囲になっている。この有効範囲を「変数のスコープ」と呼ぶ。

　ローカル変数も状態の変化をもたらすことに変わりはない。ただし、その影響範囲はプログラム全体ではなく限定されている。このためプログラマーが状態変化の影響を見極めやすい。

　<font color="red"><b>「状態は悪」といっても、実は状態自体が悪いわけではない。プログラマーが状態の変化を把握しきれないのが最大の問題なのだ。</b></font>オブジェクト指向プログラミングのように、状態をオブジェクトの内部にとじ込めることで管理しやすくするという考え方もある。

　ちなみに、先ほどのC言語のプログラムをPythonで書き換えると次のようになる。

```
state = 1

def f(x):
  global state
  result = 2 * x + state
  state += 1
  return result

print("f（2）の値は%dです" % f(2))
print("f（2）の値は%dです" % f(2))
```

　ここで肝になるのが「global state」という記述だ。Pythonの関数内からは、外側にあるグローバル変数の値をそのまま参照できる。ただし、グローバル変数の値を関数内で書き換えたい場合は、「global」というキーワードを使ってグローバル変数であることを明示する必要がある。

　なかなかうまいやり方だと思う。グローバル変数の値を定数として参照するだけなら問題が起こることはない。問題なのは、グローバル変数の値を書き換える場合だ。そこで、グローバル変数の書き換えが発生するときにはわざわざ「global」と宣言させることで、プログラマーに注意を喚起しているのだ。

#### ローカル変数を次々に使い捨てる

　状態の制限をもう一歩進めて、値を書き換えられない変数という概念も一般的になってきた。値を書き換えられる従来の変数を「ミュータブルな変数」と呼ぶのに対し、値を書き換えられない変数を「イミュータブルな変数」と呼ぶ。

　いまどきのモダンなプログラミング言語の多くは、イミュータブルな変数に対応している。例えば、RustやScalaといった言語でイミュータブルな変数を利用できる。

　変数の値を書き換えられなければ、状態が変わることもない。このためプログラマーはロジックの記述に専念でき、ミスが少なく品質の高いプログラムを期待できる。

　もっとも実際のプログラミングでは、変数の値を変えながら処理を繰り返す場合が多い。イミュータブルな変数しかない場合、こうした繰り返しをどのように実現すればいいのだろうか。

　その解の1つが再帰だ。関数内で自分自身を呼び出すことで繰り返しを実現する手法である。

　次のような疑似コードで考えてみよう。与えられた数の階乗を再帰で計算するコードになっている。C言語でもJavaScriptでも、自分が知っている言語で置き換えて考えればOKだ。

```
fact(n) {
  if (n == 1) {
    return 1;
  }
  else {
    return n*fact(n-1);
  }
}
```

　nが3の場合で考えてみよう。まずfact（3）の処理では、3は1ではないので、fact（3）が返す値は「3かけるfact（2）」になる。fact（2）の処理では、2は1ではないので、fact（2）が返す値は「2かけるfact（1）」になる。fact（1）の処理では、if文により返す値は「1」になる。

　fact（2）が返す値の中のfact（1）、およびfact（3）が返す値の中のfact（2）に対しこれらの結果を当てはめると、fact（3）が返す値は最終的に「3かける2かける1」、つまり「6」になる。ちゃんと階乗を計算できていることがわかる。

　ここでfact（3）とそこから呼び出すfact（2）の2つのfact関数に注目してみよう。これらは関数名こそ同じだが、実体は異なる環境を持つ異なる関数になる。再帰で同じ名前の関数を呼び出した時点で、新しい関数の環境が作られるからだ。

　したがって、その中のnというローカル変数も、名前は同じだが環境ごとに異なる変数になる。この場合は3という値を持つnと2という値を持つnという別々の変数があることになる。

　つまり再帰では、nの値を書き換えるのではなく、nというローカル変数を新たに作っては使い捨てにする。これにより、イミュータブルな変数でも繰り返し処理を実現できるのだ。

　こうした再帰は、実際にはスタックなどのリソースを無駄に消費するので、あまり書かないほうがいいとされている。ただし、「末尾再帰最適化」という機能を持つ言語（もしくは言語処理系の実装）では、再帰を「末尾再帰」という形式で表現することで、コンピューターの内部ではリソースを消費しない形で処理してくれる。

　結局のところ、プログラミング言語が開発されたのも、様々なプログラミング技法が編み出されたのも、人間の能力に限界があるためなのではないか。状態にしても、すべての変化とその影響をプログラマーが完璧に把握できるなら、どれだけ変化しても問題はない。

　仮に全知全能のプログラマーがいるとすれば、正しく動作するプログラムをそのまま頭から書きくだしていくはずだ。プログラミング言語を使わなくても、そのコンピューターで動作する機械語を直接記述すればいい。機能分割も必要ない。正しく動作するなら、すべての要素を詰め込んだ一枚岩のプログラムで十分だ。

　こうして考えていくと、頭の悪い人間が頭のいいコンピューターに無理やり合わせているのがプログラミングという作業の実態ではないかという気がしてくる。プログラミングとは、機械ではない人間が機械と折り合いをつけるための妥協の産物なのかもしれない。
